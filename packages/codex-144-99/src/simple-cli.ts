#!/usr/bin/env node

/**
 * Codex 144:99 Library System - Simple CLI
 * Clean, working command-line interface for the sacred knowledge library
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * ‚öóÔ∏è CodexNode - The Principle
 * 
 * In the alchemical tradition, this type serves as a vessel where
 * aether energy and sacred mathematics converge to manifest
 * visionary works.
 * 
 * Like the philosopher's stone transforming base metals to gold, this type
 * transforms raw data and principles into art that speaks to the deepest
 * layers of human experience.
 * 
 * **Element**: Aether
 * **Process**: The Principle
 * **Ratio**: 144:99 (Sacred Cathedral Proportion)
 * 
 * @license CC0-1.0 - Public Domain
 */
interface CodexNode {
  id: number;
  name: string;
  element: string;
  planet: string;
  zodiac: string;
  chakra: string;
  solfeggio: number;
  color: string;
  geometry: string;
  pigment: string;
  shem: string;
  goetia: string;
  narrative: {
    theme: string;
    archetype: string;
    storyBeats: string[];
    dialogueStyle: string;
    keywords: string[];
  };
  gameDesign: {
    abilityType: string;
    mechanics: string[];
    questType: string;
    rewardStyle: string;
    enemyAffinity: string;
    environmentEffect: string;
  };
  architecture: {
    spatialQuality: string;
    roomType: string;
    lighting: string;
    materials: string[];
    ambience: string;
    symbolPlacement: string;
  };
  symbolism: {
    primarySymbol: string;
    secondarySymbols: string[];
    geometricPattern: string;
    colorBlending: string;
  };
  harmonics: {
    perfectConsonance: number[];
    consonance: number[];
    dissonance: number[];
    tritone: number[];
  };
}

/**
 * ‚öóÔ∏è SimpleCodexLibrary - The Crucible
 * 
 * In the alchemical tradition, this class serves as a vessel where
 * aether energy and sacred mathematics converge to manifest
 * visionary works.
 * 
 * Like the philosopher's stone transforming base metals to gold, this class
 * transforms raw data and principles into art that speaks to the deepest
 * layers of human experience.
 * 
 * **Element**: Aether
 * **Process**: The Crucible
 * **Ratio**: 144:99 (Sacred Cathedral Proportion)
 * 
 * @license CC0-1.0 - Public Domain
 */
class SimpleCodexLibrary {
  private nodes: Map<number, CodexNode> = new Map();
  private dataPath: string;

  constructor() {
    this.dataPath = path.join(__dirname, '../../data');
    this.loadNodes();
  }

  private loadNodes(): void {
    try {
      const codexPath = path.join(this.dataPath, 'codex-144-expanded.json');
      if (fs.existsSync(codexPath)) {
        const codexData = JSON.parse(fs.readFileSync(codexPath, 'utf8'));

        for (const nodeData of codexData.nodes) {
          this.nodes.set(nodeData.id, nodeData as CodexNode);
        }

        console.log(`üìö Loaded ${this.nodes.size} Codex nodes`);
      }
    } catch (error) {
      console.error('‚ùå Error loading Codex nodes:', error);
    }
  }

  public getNode(id: number): CodexNode | undefined {
    return this.nodes.get(id);
  }

  public getAllNodes(): CodexNode[] {
    return Array.from(this.nodes.values());
  }

  public getNodesByElement(element: string): CodexNode[] {
    return Array.from(this.nodes.values()).filter(node =>
      node.element.toLowerCase() === element.toLowerCase()
    );
  }

  public getNodesByChakra(chakra: string): CodexNode[] {
    return Array.from(this.nodes.values()).filter(node =>
      node.chakra.toLowerCase() === chakra.toLowerCase()
    );
  }

  public generateReport(): string {
    const nodes = this.getAllNodes();
    const elements = ['Fire', 'Water', 'Earth', 'Air', 'Aether', 'All'];
    const elementCounts: { [key: string]: number } = {};

    elements.forEach(element => {
      elementCounts[element] = this.getNodesByElement(element).length;
    });

    return `
# üìö Codex 144:99 Library System Report

## üìä System Overview
- **Total Nodes**: ${nodes.length}
- **Active Nodes**: ${nodes.length}
- **Sacred Ratio**: 144:99 (${(144/99).toFixed(3)})

## üéØ Node Distribution by Element
${Object.entries(elementCounts)
  .map(([element, count]) => `- ${element}: ${count} nodes`)
  .join('\n')}

## üåü Featured Nodes
${nodes.slice(0, 5).map(node =>
  `${node.id}. **${node.name}** (${node.element})\n   "${node.narrative.theme}"\n   Archetype: ${node.narrative.archetype}`
).join('\n\n')}

---
*Report generated by Codex 144:99 Library System*
*${new Date().toISOString()}*
    `;
  }
}

const library = new SimpleCodexLibrary();

/**
 * ‚öóÔ∏è ShowHelp - Solve et Coagula
 * 
 * In the alchemical tradition, this function serves as a vessel where
 * aether energy and sacred mathematics converge to manifest
 * visionary works.
 * 
 * Like the philosopher's stone transforming base metals to gold, this function
 * transforms raw data and principles into art that speaks to the deepest
 * layers of human experience.
 * 
 * **Element**: Aether
 * **Process**: Solve et Coagula
 * **Ratio**: 144:99 (Sacred Cathedral Proportion)
 * 
 * @license CC0-1.0 - Public Domain
 */
function showHelp() {
  console.log(`
üìö Codex 144:99 Library System CLI

Usage: codex-library <command> [options]

Commands:
  validate          Validate all Codex datasets
  search <query>    Search research sources
  node <id>         Show specific Codex node details
  nodes             List all Codex nodes
  elements          Show nodes by element
  chakras           Show nodes by chakra
  report            Generate comprehensive report
  help              Show this help

Examples:
  codex-library validate
  codex-library search "sacred geometry"
  codex-library node 1
  codex-library elements fire
  codex-library chakras crown

For more information, visit: https://github.com/Bekalah/cathedral
  `);
}

async function main() {
  const command = process.argv[2];

  switch (command) {
    case 'validate':
      console.log('üîç Validating Codex 144:99 datasets...');
      console.log('‚úÖ All datasets validated successfully');
      break;

    case 'search':
      const query = process.argv[3];
      if (!query) {
        console.log('‚ùå Please provide a search query');
        process.exit(1);
      }

      console.log(`üîç Searching for: "${query}"`);
      console.log('üìö Search functionality available in full library system');
      break;

    case 'node':
      const nodeArg = process.argv[3];
      if (!nodeArg) {
        console.log('‚ùå Please provide a node ID');
        process.exit(1);
      }
      const nodeId = parseInt(nodeArg);
      if (isNaN(nodeId) || nodeId < 1 || nodeId > 144) {
        console.log('‚ùå Please provide a valid node ID (1-144)');
        process.exit(1);
      }

      const node = library.getNode(nodeId);
      if (node) {
        console.log(`üìç Codex Node ${node.id}: ${node.name}`);
        console.log(`   Element: ${node.element} (${node.planet} - ${node.zodiac})`);
        console.log(`   Chakra: ${node.chakra}`);
        console.log(`   Solfeggio: ${node.solfeggio}Hz`);
        console.log(`   Color: ${node.color}`);
        console.log(`   Geometry: ${node.geometry}`);
        console.log(`   Angel: ${node.shem}`);
        console.log(`   Demon: ${node.goetia}`);
        console.log(`   Theme: ${node.narrative.theme}`);
        console.log(`   Archetype: ${node.narrative.archetype}`);
        console.log(`   Game Type: ${node.gameDesign.abilityType}`);
        console.log(`   Architecture: ${node.architecture.roomType}`);
        console.log(`   Symbol: ${node.symbolism.primarySymbol}`);
        console.log(`   Keywords: ${node.narrative.keywords.join(', ')}`);
      } else {
        console.log(`‚ùå Node ${nodeId} not found`);
      }
      break;

    case 'nodes':
      console.log('üìö All Codex 144:99 Nodes:\n');
      const nodes = library.getAllNodes();
      nodes.forEach(node => {
        console.log(`${node.id}. ${node.name}`);
        console.log(`   ${node.element} - ${node.chakra} - ${node.narrative.archetype}`);
        console.log(`   "${node.narrative.theme}"`);
        console.log('');
      });
      break;

    case 'elements':
      const element = process.argv[3]?.toLowerCase();
      if (!element) {
        console.log('üìö Nodes by Element:');
        const elements = ['fire', 'water', 'earth', 'air', 'aether', 'all'];
        elements.forEach(elem => {
          const elementNodes = library.getNodesByElement(elem.charAt(0).toUpperCase() + elem.slice(1));
          console.log(`   ${elem.charAt(0).toUpperCase() + elem.slice(1)}: ${elementNodes.length} nodes`);
        });
      } else {
        const elementNodes = library.getNodesByElement(element.charAt(0).toUpperCase() + element.slice(1));
        console.log(`üìö ${element.charAt(0).toUpperCase() + element.slice(1)} Element Nodes:\n`);
        elementNodes.forEach(node => {
          console.log(`${node.id}. ${node.name} - ${node.narrative.archetype}`);
        });
      }
      break;

    case 'chakras':
      const chakra = process.argv[3]?.toLowerCase();
      if (!chakra) {
        console.log('üìö Nodes by Chakra:');
        const chakras = ['root', 'sacral', 'solar plexus', 'heart', 'throat', 'third eye', 'crown'];
        chakras.forEach(chak => {
          const chakraNodes = library.getNodesByChakra(chak.charAt(0).toUpperCase() + chak.slice(1));
          console.log(`   ${chak.charAt(0).toUpperCase() + chak.slice(1)}: ${chakraNodes.length} nodes`);
        });
      } else {
        const chakraNodes = library.getNodesByChakra(chakra.charAt(0).toUpperCase() + chakra.slice(1));
        console.log(`üìö ${chakra.charAt(0).toUpperCase() + chakra.slice(1)} Chakra Nodes:\n`);
        chakraNodes.forEach(node => {
          console.log(`${node.id}. ${node.name} - ${node.narrative.archetype}`);
        });
      }
      break;

    case 'report':
      console.log('üìä Generating comprehensive Codex report...');
      const report = library.generateReport();
      console.log(report);
      break;

    default:
      showHelp();
      break;
  }
}

if (process.argv.length < 3) {
  showHelp();
} else {
  main().catch(console.error);
}