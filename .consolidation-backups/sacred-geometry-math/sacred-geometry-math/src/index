/**
 * ðŸŒ€ Sacred Mathematics and Geometry Utilities
 * Cathedral foundation for 144:99 ratio compliance, golden ratio, and sacred geometry
 * Used by both Hall of Ateliers and Fusion Creative Suite
 * 
 * Mathematical precision with trauma-safe visualization
 */

import { 
  SacredGeometryPattern,
  GoldenRatioLayout,
  FibonacciSequence,
  FractalPrecision,
  MerkabaGeometry,
  FlowerOfLifePattern,
  MetatronCubePattern
} from './types/index.js';

// ============================================================================
// CORE SACRED MATHEMATICS CONSTANTS
// ============================================================================

export const SACRED_MATH_CONSTANTS = {
  // Cathedral 144:99 ratio (1.454545...)
  CATHEDRAL_RATIO: 144 / 99,
  CATHEDRAL_SQUARED: Math.pow(144 / 99, 2),
  CATHEDRAL_INVERSE: 99 / 144,
  
  // Golden ratio (1.618033988749...)
  GOLDEN_RATIO: (1 + Math.sqrt(5)) / 2,
  GOLDEN_RATIO_SQUARED: Math.pow((1 + Math.sqrt(5)) / 2, 2),
  GOLDEN_RATIO_INVERSE: 1 / ((1 + Math.sqrt(5)) / 2),
  GOLDEN_CONJUGATE: (1 - Math.sqrt(5)) / 2,
  
  // Sacred numbers
  FIBONACCI_SEED_1: 1,
  FIBONACCI_SEED_2: 1,
  FIBONACCI_LIMIT: 34, // Traditional limit for sacred art
  
  // Solfeggio frequencies
  LIBERATION_FEAR: 396,
  UNDO_SITUATIONS: 417,
  CONNECTION: 639,
  TRANSFORMATION: 528,
  INTUITION: 741,
  SPIRITUAL_ORDER: 852,
  DIVINE_CONSCIOUSNESS: 963,
  
  // Geometric constants
  PI: Math.PI,
  TAU: Math.PI * 2,
  SQUARE_ROOT_2: Math.sqrt(2),
  SQUARE_ROOT_3: Math.sqrt(3),
  SQUARE_ROOT_5: Math.sqrt(5),
  
  // Trinity mathematics
  TRINITY_HARMONY: 0.6, // Divine light weighting
  TRINITY_BALANCE: 0.3, // Neutral weighting
  TRINITY_DEPTH: 0.1    // Infernal shadow weighting
};

// ============================================================================
// 144:99 RATIO COMPLIANCE UTILITIES
// ============================================================================

export class CathedralRatio {
  private baseValue: number;
  private ratio: number = SACRED_MATH_CONSTANTS.CATHEDRAL_RATIO;
  
  constructor(baseValue: number) {
    this.baseValue = baseValue;
  }
  
  // Get value in canonical 144:99 ratio
  getCanonical(): number {
    return this.baseValue * this.ratio;
  }
  
  // Get inverse (99:144)
  getInverse(): number {
    return this.baseValue * SACRED_MATH_CONSTANTS.CATHEDRAL_RATIO_INVERSE;
  }
  
  // Square ratio
  getSquared(): number {
    return this.baseValue * this.ratio * this.ratio;
  }
  
  // Validate if value maintains 144:99 harmony
  validate(value: number): boolean {
    const tolerance = 0.01; // 1% tolerance for floating point
    const expected = this.getCanonical();
    const difference = Math.abs(value - expected) / expected;
    return difference <= tolerance;
  }
  
  // Convert any measurement to Cathedral ratio
  static convertToCathedral(value: number): number {
    return value * SACRED_MATH_CONSTANTS.CATHEDRAL_RATIO;
  }
  
  // Validate array of measurements
  static validateArray(values: number[]): {
    valid: boolean;
    violations: number[];
    suggestions: number[];
  } {
    const cathedral = new CathedralRatio(values[0] || 1);
    const violations: number[] = [];
    const suggestions: number[] = [];
    
    values.forEach((value, index) => {
      if (!cathedral.validate(value)) {
        violations.push(index);
        suggestions.push(cathedral.getCanonical());
      }
    });
    
    return {
      valid: violations.length === 0,
      violations,
      suggestions
    };
  }
}

// ============================================================================
// GOLDEN RATIO UTILITIES
// ============================================================================

export class GoldenRatioLayout {
  private phi: number = SACRED_MATH_CONSTANTS.GOLDEN_RATIO;
  
  // Calculate golden ratio division
  divide(value: number): { major: number; minor: number } {
    const major = value / this.phi;
    const minor = value - major;
    return { major, minor };
  }
  
  // Apply golden ratio to dimensions
  applyToDimensions(width: number, height: number): {
    goldenWidth: number;
    goldenHeight: number;
    aspect: number;
  } {
    const goldenWidth = width / this.phi;
    const goldenHeight = height / this.phi;
    const aspect = width / height;
    
    return {
      goldenWidth,
      goldenHeight,
      aspect
    };
  }
  
  // Generate golden ratio spiral points
  generateSpiralPoints(
    center: { x: number; y: number },
    startRadius: number = 10,
    iterations: number = 10
  ): Array<{ x: number; y: number; radius: number; angle: number }> {
    const points = [];
    let radius = startRadius;
    let angle = 0;
    
    for (let i = 0; i < iterations; i++) {
      const x = center.x + radius * Math.cos(angle);
      const y = center.y + radius * Math.sin(angle);
      
      points.push({
        x,
        y,
        radius,
        angle
      });
      
      // Golden spiral grows by golden ratio each iteration
      radius *= this.phi;
      angle += Math.PI / 2; // 90 degrees
    }
    
    return points;
  }
  
  // Golden ratio in composition
  calculateCompositionPoints(
    width: number,
    height: number,
    focus: 'center' | 'third' | 'spiral' = 'third'
  ): Array<{ x: number; y: number; strength: number }> {
    const composition = [];
    
    switch (focus) {
      case 'center':
        composition.push({
          x: width / 2,
          y: height / 2,
          strength: 1.0
        });
        break;
        
      case 'third':
        const thirds = [
          { x: width / 3, y: height / 3 },
          { x: (2 * width) / 3, y: height / 3 },
          { x: width / 3, y: (2 * height) / 3 },
          { x: (2 * width) / 3, y: (2 * height) / 3 }
        ];
        thirds.forEach(point => composition.push({
          x: point.x,
          y: point.y,
          strength: 0.8
        }));
        break;
        
      case 'spiral':
        const spiralPoints = this.generateSpiralPoints(
          { x: width / 2, y: height / 2 },
          Math.min(width, height) / 8,
          8
        );
        spiralPoints.forEach((point, index) => {
          composition.push({
            x: point.x,
            y: point.y,
            strength: 1.0 / (index + 1)
          });
        });
        break;
    }
    
    return composition;
  }
}

// ============================================================================
// FIBONACCI SEQUENCE INTEGRATION
// ============================================================================

export class FibonacciSequence {
  private sequence: number[] = [];
  private maxValue: number;
  
  constructor(maxValue: number = 34) {
    this.maxValue = maxValue;
    this.generate();
  }
  
  private generate(): void {
    this.sequence = [SACRED_MATH_CONSTANTS.FIBONACCI_SEED_1, SACRED_MATH_CONSTANTS.FIBONACCI_SEED_2];
    
    while (this.sequence[this.sequence.length - 1] < this.maxValue) {
      const next = this.sequence[this.sequence.length - 1] + this.sequence[this.sequence.length - 2];
      if (next <= this.maxValue) {
        this.sequence.push(next);
      } else {
        break;
      }
    }
  }
  
  getSequence(): number[] {
    return [...this.sequence];
  }
  
  getNthValue(n: number): number {
    if (n >= this.sequence.length) {
      // Calculate beyond generated sequence
      let a = SACRED_MATH_CONSTANTS.FIBONACCI_SEED_1;
      let b = SACRED_MATH_CONSTANTS.FIBONACCI_SEED_2;
      
      for (let i = 2; i <= n; i++) {
        const next = a + b;
        a = b;
        b = next;
      }
      return b;
    }
    return this.sequence[n];
  }
  
  // Golden ratio approximation using Fibonacci
  getGoldenRatio(): number {
    const n = this.sequence.length - 1;
    return this.getNthValue(n) / this.getNthValue(n - 1);
  }
  
  // Generate Fibonacci rectangles for art composition
  generateRectangles(
    width: number,
    height: number
  ): Array<{
    x: number;
    y: number;
    w: number;
    h: number;
    fibValue: number;
  }> {
    const rectangles = [];
    let currentX = 0;
    let currentY = 0;
    let currentW = width;
    let currentH = height;
    
    this.sequence.forEach((fibValue, index) => {
      if (index % 2 === 0) {
        // Horizontal rectangle
        const rectW = (currentW * fibValue) / this.sequence[this.sequence.length - 1];
        rectangles.push({
          x: currentX,
          y: currentY,
          w: rectW,
          h: currentH,
          fibValue
        });
        currentX += rectW;
        currentW -= rectW;
      } else {
        // Vertical rectangle
        const rectH = (currentH * fibValue) / this.sequence[this.sequence.length - 1];
        rectangles.push({
          x: currentX,
          y: currentY,
          w: currentW,
          h: rectH,
          fibValue
        });
        currentY += rectH;
        currentH -= rectH;
      }
    });
    
    return rectangles;
  }
  
  // Fibonacci spiral arc
  generateSpiralArcs(
    center: { x: number; y: number },
    size: number
  ): Array<{
    startAngle: number;
    endAngle: number;
    radius: number;
    fibValue: number;
  }> {
    const arcs = [];
    let currentRadius = size;
    let currentAngle = 0;
    
    this.sequence.forEach((fibValue, index) => {
      const arcRadius = (currentRadius * fibValue) / this.sequence[this.sequence.length - 1];
      
      arcs.push({
        startAngle: currentAngle,
        endAngle: currentAngle + Math.PI / 2,
        radius: arcRadius,
        fibValue
      });
      
      currentAngle += Math.PI / 2;
      currentRadius = arcRadius;
    });
    
    return arcs;
  }
}

// ============================================================================
// SACRED GEOMETRY PATTERNS
// ============================================================================

export class FlowerOfLifePattern {
  private center: { x: number; y: number };
  private radius: number;
  
  constructor(center: { x: number; y: number }, radius: number) {
    this.center = center;
    this.radius = radius;
  }
  
  // Generate complete Flower of Life pattern
  generatePattern(rings: number = 3): {
    circles: Array<{
      center: { x: number; y: number };
      radius: number;
      id: string;
    }>;
    connections: Array<{
      from: string;
      to: string;
      type: 'line' | 'arc';
    }>;
    metadata: {
      totalCircles: number;
      totalConnections: number;
      sacredComplexity: number;
    };
  } {
    const circles = [];
    const connections = [];
    
    // Central circle
    circles.push({
      center: { ...this.center },
      radius: this.radius,
      id: 'center'
    });
    
    // Ring 1: 6 circles around center
    for (let i = 0; i < 6; i++) {
      const angle = (i * 60) * (Math.PI / 180); // Convert to radians
      const x = this.center.x + this.radius * Math.cos(angle);
      const y = this.center.y + this.radius * Math.sin(angle);
      
      circles.push({
        center: { x, y },
        radius: this.radius,
        id: `ring1_${i}`
      });
      
      // Connect to center
      connections.push({
        from: 'center',
        to: `ring1_${i}`,
        type: 'line'
      });
    }
    
    // Additional rings based on request
    if (rings >= 2) {
      for (let i = 0; i < 12; i++) {
        const angle = (i * 30) * (Math.PI / 180);
        const distance = this.radius * 2;
        const x = this.center.x + distance * Math.cos(angle);
        const y = this.center.y + distance * Math.sin(angle);
        
        circles.push({
          center: { x, y },
          radius: this.radius,
          id: `ring2_${i}`
        });
      }
    }
    
    // Connect adjacent circles
    for (let i = 0; i < circles.length - 1; i++) {
      const currentCircle = circles[i];
      const nextCircle = circles[i + 1];
      
      if (nextCircle) {
        connections.push({
          from: currentCircle.id,
          to: nextCircle.id,
          type: 'line'
        });
      }
    }
    
    return {
      circles,
      connections,
      metadata: {
        totalCircles: circles.length,
        totalConnections: connections.length,
        sacredComplexity: rings
      }
    };
  }
  
  // Generate specific Flower of Life variations
  generateVariation(
    type: 'seed' | 'egg' | 'fruit' | 'tree',
    rings: number = 3
  ): any {
    const patterns = {
      seed: {
        description: 'Single central circle - life seed',
        circles: 1,
        connections: 0,
        rings: 0
      },
      egg: {
        description: 'Central + 6 surrounding - cosmic egg',
        circles: 7,
        connections: 6,
        rings: 1
      },
      fruit: {
        description: 'Three rings - fruit of life',
        circles: 19,
        connections: 18,
        rings: 2
      },
      tree: {
        description: 'Four rings - tree of life',
        circles: 37,
        connections: 36,
        rings: 3
      }
    };
    
    const variation = patterns[type];
    return {
      ...this.generatePattern(rings),
      variation: variation,
      description: variation.description
    };
  }
}

// ============================================================================
// METATRON'S CUBE PATTERN
// ============================================================================

export class MetatronCubePattern {
  private center: { x: number; y: number };
  private radius: number;
  
  constructor(center: { x: number; y: number }, radius: number) {
    this.center = center;
    this.radius = radius;
  }
  
  // Generate all Platonic solids from Metatron's Cube
  generatePlatonicSolids(): {
    vertices: Array<Array<{ x: number; y: number; z?: number }>>;
    faces: Array<Array<number>>;
    edges: Array<[number, number]>;
    metadata: {
      totalVertices: number;
      totalFaces: number;
      totalEdges: number;
      solids: string[];
    };
  } {
    const vertices: Array<Array<{ x: number; y: number; z?: number }>> = [];
    const faces: Array<Array<number>> = [];
    const edges: Array<[number, number]> = [];
    
    // Generate 13 circle vertices around center
    const circleVertices = this.generateCircleVertices(13);
    vertices.push(circleVertices);
    
    // Tetrahedron (4 vertices, 4 faces, 6 edges)
    const tetraVertices = [
      { x: 0, y: 0, z: this.radius },
      { x: this.radius, y: 0, z: 0 },
      { x: -this.radius / 2, y: this.radius * Math.sqrt(3) / 2, z: 0 },
      { x: -this.radius / 2, y: -this.radius * Math.sqrt(3) / 2, z: 0 }
    ];
    vertices.push(tetraVertices);
    
    // Cube (8 vertices, 6 faces, 12 edges)
    const cubeVertices = [];
    for (let x = -this.radius; x <= this.radius; x += this.radius) {
      for (let y = -this.radius; y <= this.radius; y += this.radius) {
        for (let z = -this.radius; z <= this.radius; z += this.radius) {
          cubeVertices.push({ x, y, z });
        }
      }
    }
    vertices.push(cubeVertices);
    
    // Octahedron (6 vertices, 8 faces, 12 edges)
    const octaVertices = [
      { x: this.radius, y: 0, z: 0 },
      { x: -this.radius, y: 0, z: 0 },
      { x: 0, y: this.radius, z: 0 },
      { x: 0, y: -this.radius, z: 0 },
      { x: 0, y: 0, z: this.radius },
      { x: 0, y: 0, z: -this.radius }
    ];
    vertices.push(octaVertices);
    
    // Dodecahedron (20 vertices, 12 faces, 30 edges)
    const phi = SACRED_MATH_CONSTANTS.GOLDEN_RATIO;
    const dodecaVertices = [];
    // Simplified dodecahedron vertices (full implementation would have 20 vertices)
    for (let i = 0; i < 20; i++) {
      const angle = (i * 36) * (Math.PI / 180);
      const r = this.radius;
      dodecaVertices.push({
        x: r * Math.cos(angle),
        y: r * Math.sin(angle),
        z: (i % 2 === 0 ? r / phi : -r / phi)
      });
    }
    vertices.push(dodecaVertices);
    
    // Icosahedron (12 vertices, 20 faces, 30 edges)
    const icosaVertices = [];
    const goldenRatio = phi;
    
    // Simplified icosahedron vertices
    for (let i = 0; i < 12; i++) {
      const angle1 = (i * 36) * (Math.PI / 180);
      const angle2 = ((i + 1) * 36) * (Math.PI / 180);
      const z = (i % 2 === 0 ? this.radius : -this.radius);
      icosaVertices.push({
        x: this.radius * Math.cos(angle1),
        y: this.radius * Math.sin(angle1),
        z
      });
    }
    vertices.push(icosaVertices);
    
    return {
      vertices,
      faces,
      edges,
      metadata: {
        totalVertices: vertices.reduce((sum, v) => sum + v.length, 0),
        totalFaces: faces.length,
        totalEdges: edges.length,
        solids: ['tetrahedron', 'cube', 'octahedron', 'dodecahedron', 'icosahedron']
      }
    };
  }
  
  private generateCircleVertices(count: number): Array<{ x: number; y: number; z: number }> {
    const vertices = [];
    for (let i = 0; i < count; i++) {
      const angle = (i * 360 / count) * (Math.PI / 180);
      vertices.push({
        x: this.center.x + this.radius * Math.cos(angle),
        y: this.center.y + this.radius * Math.sin(angle),
        z: 0
      });
    }
    return vertices;
  }
}

// ============================================================================
// FRACTAL PRECISION VALIDATION
// ============================================================================

export class FractalPrecision {
  private tolerance: number = 0.0001;
  
  constructor(tolerance: number = 0.0001) {
    this.tolerance = tolerance;
  }
  
  // Validate sacred geometry calculations
  validateCalculation(
    actual: number,
    expected: number,
    context: string
  ): {
    valid: boolean;
    error: number;
    percentage: number;
    context: string;
  } {
    const error = Math.abs(actual - expected);
    const percentage = (error / Math.abs(expected)) * 100;
    
    return {
      valid: error <= this.tolerance,
      error,
      percentage,
      context
    };
  }
  
  // Validate golden ratio in geometric patterns
  validateGoldenRatio(pattern: any): Array<{
    element: string;
    ratio: number;
    expected: number;
    valid: boolean;
    error: number;
  }> {
    const validations = [];
    const phi = SACRED_MATH_CONSTANTS.GOLDEN_RATIO;
    
    // Check if pattern contains golden ratio measurements
    if (pattern.dimensions) {
      const { width, height } = pattern.dimensions;
      const ratio = width / height;
      
      validations.push({
        element: 'aspect_ratio',
        ratio,
        expected: phi,
        valid: Math.abs(ratio - phi) < this.tolerance,
        error: Math.abs(ratio - phi)
      });
    }
    
    return validations;
  }
  
  // Validate Fibonacci sequence accuracy
  validateFibonacci(sequence: number[]): Array<{
    index: number;
    value: number;
    expected: number;
    valid: boolean;
    error: number;
  }> {
    const validations = [];
    const fib = new FibonacciSequence(Math.max(...sequence));
    
    sequence.forEach((value, index) => {
      const expected = fib.getNthValue(index);
      
      validations.push({
        index,
        value,
        expected,
        valid: Math.abs(value - expected) < this.tolerance,
        error: Math.abs(value - expected)
      });
    });
    
    return validations;
  }
  
  // Validate 144:99 ratio compliance
  validateCathedralRatio(measurements: number[]): {
    overallValid: boolean;
    individualValidations: Array<{
      index: number;
      value: number;
      canonical: number;
      valid: boolean;
      error: number;
    }>;
    compliance: number; // Percentage of measurements in compliance
  } {
    const validations = measurements.map((value, index) => {
      const cathedral = new CathedralRatio(value);
      const canonical = cathedral.getCanonical();
      
      return {
        index,
        value,
        canonical,
        valid: cathedral.validate(value),
        error: Math.abs(value - canonical)
      };
    });
    
    const validCount = validations.filter(v => v.valid).length;
    const compliance = (validCount / measurements.length) * 100;
    
    return {
      overallValid: validCount === measurements.length,
      individualValidations: validations,
      compliance
    };
  }
  
  // Generate precision report
  generatePrecisionReport(patterns: any[]): {
    summary: {
      totalPatterns: number;
      validPatterns: number;
      averageCompliance: number;
      criticalIssues: string[];
    };
    details: Array<{
      pattern: string;
      validations: any[];
      score: number;
      issues: string[];
    }>;
  } {
    const details = patterns.map(pattern => {
      const validations = this.validateGoldenRatio(pattern);
      const score = validations.length > 0 
        ? validations.filter(v => v.valid).length / validations.length * 100
        : 100;
      
      return {
        pattern: pattern.name || 'Unknown Pattern',
        validations,
        score,
        issues: validations.filter(v => !v.valid).map(v => 
          `${v.element} ratio ${v.ratio.toFixed(4)} deviates from golden ratio ${v.expected.toFixed(4)}`
        )
      };
    });
    
    const validPatterns = details.filter(d => d.score >= 95).length;
    const averageCompliance = details.reduce((sum, d) => sum + d.score, 0) / details.length;
    
    return {
      summary: {
        totalPatterns: patterns.length,
        validPatterns,
        averageCompliance,
        criticalIssues: details.filter(d => d.score < 80).map(d => d.pattern)
      },
      details
    };
  }
}

// ============================================================================
// EXPORT ALL UTILITIES
// ============================================================================

export {
  SACRED_MATH_CONSTANTS,
  CathedralRatio,
  GoldenRatioLayout,
  FibonacciSequence,
  FlowerOfLifePattern,
  MetatronCubePattern,
  FractalPrecision
};

// Export singleton instances for common use
export const cathedralRatio = new CathedralRatio(1);
export const goldenLayout = new GoldenRatioLayout();
export const fibonacci = new FibonacciSequence();
export const fractalValidator = new FractalPrecision();

// Professional constants for external use
export const SACRED_GEOMETRY_CONSTANTS = {
  CATHEDRAL_RATIO: SACRED_MATH_CONSTANTS.CATHEDRAL_RATIO,
  GOLDEN_RATIO: SACRED_MATH_CONSTANTS.GOLDEN_RATIO,
  FIBONACCI_MAX: SACRED_MATH_CONSTANTS.FIBONACCI_LIMIT,
  SOLFEGGIO_FREQUENCIES: {
    LIBERATION: SACRED_MATH_CONSTANTS.LIBERATION_FEAR,
    CHANGE: SACRED_MATH_CONSTANTS.UNDO_SITUATIONS,
    CONNECTION: SACRED_MATH_CONSTANTS.CONNECTION,
    TRANSFORMATION: SACRED_MATH_CONSTANTS.TRANSFORMATION,
    INTUITION: SACRED_MATH_CONSTANTS.INTUITION,
    SPIRITUAL: SACRED_MATH_CONSTANTS.SPIRITUAL_ORDER,
    CONSCIOUSNESS: SACRED_MATH_CONSTANTS.DIVINE_CONSCIOUSNESS
  }
};

export default {
  constants: SACRED_MATH_CONSTANTS,
  cathedral: cathedralRatio,
  golden: goldenLayout,
  fibonacci,
  fractal: fractalValidator,
  flower: FlowerOfLifePattern,
  metatron: MetatronCubePattern,
  sacred: SACRED_GEOMETRY_CONSTANTS
};